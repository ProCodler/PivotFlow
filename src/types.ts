import { Principal } from '@dfinity/principal';

// This file is intended for shared frontend-specific types or to augment/mirror backend types for frontend use.
// Ideally, for backend data structures, you would rely on types generated by `dfx generate`
// from your Motoko/Rust Candid definitions. The types in `zero_fee_bot_backend.did.js` (or a .d.ts from it)
// would be the source of truth.
// These are here as placeholders or for frontend-specific extensions.

// --- Re-export or refine types from the .did.js stub ---
// You might not need to redefine them if your .did.js JSDoc or a generated .d.ts is sufficient.
// However, for stricter frontend usage or if you don't have .d.ts, you can define them here.

export interface NftAlertRecord {
  id: string;
  collectionSlug: string;
  targetPrice: number;
  targetCurrency: 'ETH' | 'SOL' | 'ICP' | 'USD';
  alertType: 'DropBelow' | 'RiseAbove' | 'AnyChange' | 'PercentageChange';
  percentageChangeValue?: number;
  gasLimit?: number; // Gwei
  marketplace: 'OpenSea' | 'Blur' | 'MagicEden' | 'Entrepot'; // Extend as needed
  isActive: boolean;
  lastAlerted?: bigint; // Nanoseconds timestamp
  userId: Principal; // Or string if you prefer principal.toText() immediately
}

export interface GasAlertRecord {
  id: string;
  blockchain: 'Ethereum' | 'Polygon' | 'BNBChain'; // Extend as needed
  maxGwei: number;
  priorityTier: 'Fast' | 'Standard' | 'Slow';
  isActive: boolean;
  userId: Principal;
}

export interface MonitoredTokenRecord {
  id: string; // e.g., "dogecoin-ethereum" or "internet-computer-icp" (unique identifier)
  symbol: string; // e.g., DOGE, ICP
  name: string;
  chain: 'Ethereum' | 'Polygon' | 'ICP' | 'BNBChain' | 'Solana'; // Extend as needed
  contractAddress?: string; // For EVM tokens
  canisterId?: string; // For ICP tokens (if it's a specific ICRC1/2 token, not just native ICP)
  targetPrice?: number; // In USD
  alertType?: 'DropBelow' | 'RiseAbove' | 'PercentageChange';
  percentageChangeValue?: number; // e.g., 10 for 10%
  isActive: boolean;
  userId: Principal;
}

export interface CachedNftCollectionRecord {
  slug: string;
  name: string;
  floorPrice: number;
  currency: string; // Native currency of the floor price (ETH, SOL, ICP)
  timestamp: bigint; // Nanoseconds timestamp
  // Add other relevant fields like imageUrl, description if backend provides
}

export interface GasPriceTierRecord {
  gwei: number;
  usd?: number; // Estimated USD cost for a standard transaction at this gwei
}

export interface CachedGasPricesRecord {
  chain: string; // e.g., Ethereum, Polygon
  fast: GasPriceTierRecord;
  standard: GasPriceTierRecord;
  slow: GasPriceTierRecord;
  timestamp: bigint; // Nanoseconds timestamp
}

export interface CachedTokenPriceRecord {
  id: string; // e.g., "bitcoin", "ethereum", "dogecoin" (usually CoinGecko ID or similar)
  symbol: string;
  name: string;
  priceUsd: number;
  timestamp: bigint; // Nanoseconds timestamp
}

export interface CanisterMetricsRecord {
  cyclesBalance: bigint;
  memorySize: bigint;
  heapMemorySize: bigint;
  // Add other metrics like computeAllocation, storageFee, etc.
}

export interface MonitoredWalletRecord {
  address: string; // Public wallet address (e.g., EVM)
  userId: Principal;
  // chain?: 'Ethereum' | 'Polygon'; // If supporting multiple types of non-ICP wallets
  // name?: string; // User-given alias for the wallet
}

export interface PortfolioNftRecord {
  id: string; // Unique ID for the NFT (e.g., contractAddress_tokenId or backend generated)
  collectionName: string;
  collectionSlug?: string;
  name?: string; // Specific name of the NFT item, if available
  tokenId?: string; // Token ID within the collection
  imageUrl?: string;
  currentFloorPrice?: number; // In collection's native currency (e.g., ETH for an Ethereum NFT)
  floorCurrency?: string; // e.g., ETH, SOL
  ownerAddress: string; // Wallet address this NFT belongs to
  marketplaceLink?: string; // Link to a marketplace like OpenSea, MagicEden
  // chain?: string; // Chain the NFT is on, useful for multi-chain display
}

export interface ApiKeysRecord {
  openSea?: string;
  etherscan?: string;
  blur?: string;
  magicEden?: string;
  coinGecko?: string;
}

export interface UserNotificationSettingsRecord {
    adminChatId?: string; // For Telegram/Discord bot DMs etc.
    // This structure would depend on how granular notification preferences are.
    // Example: global toggles
    enableNftFloorPriceAlerts?: boolean;
    enableGasPriceAlerts?: boolean;
    enableTokenPriceAlerts?: boolean;
    // Or more granular per alert if needed, though that's usually handled on the alert record itself (isActive).
}


// --- Frontend Specific Types ---

export type ViewName = 'Dashboard' | 'NFT Alerts' | 'Blockchain Fees' | 'Portfolio' | 'Settings';

export interface NavItem {
  name: ViewName;
  icon: React.ElementType; // For Lucide icons or other React components
  requiresAuth?: boolean; // If view itself requires auth, not just actions within it
}

export interface ToastMessage {
  id: string;
  type: 'success' | 'error' | 'warning' | 'info' | 'default';
  title?: string;
  description: string;
  duration?: number;
}

// Example of a more complex type for the transaction cost calculator
export interface TransactionCostEstimate {
    costGwei: number; // Price per gas unit in Gwei for the selected tier
    costNativeToken: number; // Total cost in native token (e.g., ETH, MATIC)
    costUsd?: number; // Total cost in USD
    message: string; // Formatted string for display
    currencySymbol: string; // e.g., ETH, MATIC, ICP
}

// If you use a theme context or similar for client-side theme changes:
export interface ThemeSettings {
    isDarkMode: boolean;
    animationIntensity: number; // 0-100
}

// You can also define enums if they are used across the frontend and not just as string literals
export enum Blockchain {
    Ethereum = "Ethereum",
    Polygon = "Polygon",
    BNBChain = "BNBChain",
    Solana = "Solana",
    ICP = "ICP",
}

export enum Marketplace {
    OpenSea = "OpenSea",
    Blur = "Blur",
    MagicEden = "MagicEden",
    Entrepot = "Entrepot", // ICP Marketplace
}

// This is just a starting point. Add more types as your application grows.
// Remember to keep these consistent with your backend Candid definitions where applicable.
// Using a tool like `didc bind` to generate TypeScript from your .did file is the recommended approach for backend types.
// `dfx generate` should also provide type information.
// These manual definitions are useful when those tools aren't fully set up or for purely frontend concerns.
